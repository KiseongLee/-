'''
구현

다른 문제와는 다르게 캐릭터의 위치와 방향까지 나오기 때문에 고려해줘야한다.
1. 입력
 1) 맵의 크기 입력/캐릭터의 위치/방향/맵의 정보를 입력받는다.
 2) [위치] 캐릭터의 위치를 나타내기 위한 방향을 정하기 위해서 dx, dy값을 생성
 3) [방향] 왼쪽 방향으로 회전하는 것을 나타내는 함수값을 받아야함
2. 출력(반복문)
 4) 반복문을 통해서 출력값(방문한 칸의 수)를 구한다. --> 밑에 각주 참고

'''

n, m = map(int, input().split())            # 맵의 크기 입력 받기 n : 세로, m : 가로

x, y, direction = map(int, input().split()) # 캐릭터의 위치 좌표로 받기(x,y) / 바라보는 방향 direction(0:북, 1:동, 2:남, 3:서) 값으로 받기

d = [[0]*m for _ in range(n)]               # 방문처리를 해야하기 때문에 맵과 같은 크기의 d라는 리스트를 2차원으로 입력 받음, 처음 값은 모두 0으로 받는다
d[x][y] = 1                                 # 케릭터의 처음 위치인 x,y는 바로 방문처리를 위해 1로 값을 받음

dx = [-1, 0, 1, 0]                          # 일반적으로 방향을 설정해서 이동하는 문제 유형에서 dx, dy라는 별도의 리스트를 만들어 방향을 정하는 것이 효과적
dy = [0, 1, 0, -1]                          # 북 동 남 서 방향으로 dx, dy값 생성
  
map = [list(map(int, input().split())) for _ in range(n)]  # 실제 맵을 받음 (0:육지, 1:바다)

def turn_left():                            # 왼쪽으로 방향 전환하는 함수를 받음
    global direction                        # global 키워드 사용, 정수형 변수인 direction 변수가 함수 바깥에서 선언된 전역 변수이기 때문
    direction -= 1                          # 왼쪽으로 방향 전환을 할 때마다 direction값을 -1을 해준다
    if direction == -1:                     # direction값이 -1은 없기 때문에 -1이 되었을 때, 3값으로 바꿔준다.(북-->서)
        direction = 3

count = 1                                   # 캐릭터가 방문한 칸의 수를 출력하기 위해 값을 받는다 / 현재 위치 때문에 1로 받음
turn_time = 0                               # 왼쪽 방향으로 전환하는 횟수를 입력받아서 한바퀴 완전히 돌았을 때 조건으로 사용하기 위함.

while True:                                 # 반복문 생성, 여기서 매우 헷갈렸는데 왼쪽 방향으로 회전하는 것이 4번이니까, for문을 사용하면 되지 않을까?라는 판단을했다
    turn_left()                             # for문을 사용하면 i값을 0,1,2,3순으로만 회전을 하게 되므로 틀린 방법이 된다.
    nx = x + dx[direction]                  # 4번 회전하는 것이 그리고 계속해서 반복되어야하기 때문에 while을 쓰는게 맞다.
    ny = y + dy[direction]                  # 캐릭터는 현재 위치와 방향값이 있기 때문에 그 상태에서 바로 왼쪽으로 회전한다.
    if d[nx][ny] == 0 and map[nx][ny] == 0: # 회전한 방향에서 한 칸 앞으로 간 값 방문처리가 되지 않았고(이미 왔던 길이 아닌), 맵 상에서 갈 수 있는 장소(바다가 아닌 육지)라면
       d[nx][ny] = 1                        # 방문처리를 해주고
       x = nx                               # 캐릭터의 위치를 한 칸 앞으로 간다
       y = ny
       count += 1                           # 캐릭터가 방문한 칸의 수의 값을 1 올려준다.
       turn_time = 0                        # 왼쪽으로 회전한 수를 0으로 초기화 하고
       continue                             # continue를 통해서 밑의 구문을 실행시키지 않고 다시 반복문을 통해서 위의 값을 반복한다.

    else:                                   # 회전을 했는데 위의 조건에 부합하지 않으면 회전 수를 1 올려준다.
       turn_time += 1

    if turn_time == 4:                      # 회전 수가 4가 되었을 때(한 바퀴 돌았을 때)
        nx = x - dx[direction]              # 방향을 유지한채로(direction값 유지)뒤로 한 칸 갈 수 있는지 확인하기 위해서 nx, ny값을 받는다.
        ny = y - dy[direction]
        
        if map[nx][ny] == 0:                # 뒤의 칸이 만약에 0값(육지)이라면 
            x = nx                          # 캐릭터의 위치를 한 칸 뒤로 간다. 그리고 회전 수(turn_time)를 0으로 초기화한다.
            y = ny
        else:
            break                           # 만약에 뒤에 갈 수 없는 경우는 break를 통해 반복문을 나가게 되고 캐릭터의 움직임은 멈춘다.
        turn_time = 0

print(count)                                # 값을 출력한다.




